<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<LINK REL="stylesheet" TYPE="text/css" HREF="cocoalib-doc.css">
<TITLE>      ModuleTermOrdering</TITLE>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<P ALIGN="center"><CENTER><H1>      ModuleTermOrdering</H1>
<FONT SIZE="4">
<I>      &copy;  2005 Anna Bigatti</I><BR>
      GNU Free Documentation License, Version 1.2
</FONT></CENTER>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
    <UL>
    <LI><A HREF="#toc1">User documentation for ModuleTermOrdering</A>
      <UL>
      <LI><A HREF="#toc2">Example</A>
      </UL>
    <LI><A HREF="#toc3">Maintainer documentation for ModuleTermOrdering</A>
    <LI><A HREF="#toc4">Bugs, shortcomings and other ideas</A>
      <UL>
      <LI><A HREF="#toc5">do we need a class "shifts"?</A>
      </UL>
    </UL>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<P>
      <center><a href="index.html">CoCoALib Documentation Index</a></center>
</P>
<A NAME="toc1"></A>
<H2>User documentation for ModuleTermOrdering</H2>
<P>
An object of the class ModuleTermOrdering represents an ordering on
the module monoid of module terms, i.e. such that the
ordering respects the operation ....  
In CoCoALib orderings and gradings are intimately linked (for gradings
see also <A HREF="degree.html"><CODE>degree</CODE></A> and <A HREF="PPOrdering.html"><CODE>PPOrdering</CODE></A>).
</P>
<P>
Currently, the most typical use for a ModuleTermOrdering object is as
a constructor argument to a concrete <A HREF="FreeModule.html"><CODE>FreeModule</CODE></A>.  At the moment
there are ? functions which create new <CODE>ModuleTermOrderings</CODE>:
</P>
<P>
Pseudo-constructors: (where <CODE>PPO</CODE> is a <A HREF="PPOrdering.html"><CODE>PPOrdering</CODE></A>, <CODE>shifts</CODE> is a
<CODE>vector&lt;degree&gt;</CODE>, <CODE>perm</CODE> is <CODE>std::vector&lt;long&gt;</CODE>, <CODE>NumComponents</CODE> is a <CODE>long</CODE>)
</P>
<PRE>
    NewWDegTOPos(PPO, NumComponents);
    NewPosWDegTO(PPO, NumComponents);
    NewWDegPosTO(PPO, NumComponents);
    NewWDegTOPos(PPO, shifts);
    NewWDegPosTO(PPO, shifts);
    NewPosWDegTO(PPO, shifts);
    NewWDegTOPos(PPO, perm);
    NewWDegPosTO(PPO, perm);
    NewWDegTOPos(PPO, shifts, perm);
    NewWDegPosTO(PPO, shifts, perm);
</PRE>
<P>
where 
</P>
<PRE>
    WDeg is the degree (incl. the shifts)
    TO   is the PPOrdering (incl. the degree, i.e. the first GrDim rows)
    Pos  is the position (according to the "score" given by perm [NYI])
</PRE>
<P></P>
<A NAME="toc2"></A>
<H3>Example</H3>
<PRE>
    P = Q[x,y] with StdDegLex (==&gt; GradingDim = 1)
    P(-2) (+) P(-1)  i.e. P^2 with shifts = [(2), (1)], and WDegTOPos
    v1 = [x,0],   v2 = [0,y^2]:
    WDeg(v1) = WDeg(x)+2 = 3,  WDeg(v2) = WDeg(y^2)+1 = 3
    x &lt; y^2 according to StdDegLex  (NB: not "Lex"!)
    so v1 &lt; v2
</PRE>
<P></P>
<P>
The operations on a ModuleTermOrdering object are:
</P>
<PRE>
    out &lt;&lt; MTO;      // output the MTO object to channel out
    const std::vector&lt;degree&gt;&amp; shifts(const ModuleTermOrdering&amp; O);
    long NumComponents(const ModuleTermOrdering&amp; MTO);
    long GradingDim(const ModuleTermOrdering&amp; MTO);
    const PPOrdering&amp; ModPPOrdering(const ModuleTermOrdering&amp; MTO);
  
    bool IsWDegTOPos(const ModuleTermOrdering&amp; MTO);// true iff MTO is implemented as WDegTOPos
    bool IsPosWDegTO(const ModuleTermOrdering&amp; MTO);
    bool IsWDegPosTO(const ModuleTermOrdering&amp; MTO);
</PRE>
<P></P>
<P>
output and OpenMath output is still questionable.
</P>
<A NAME="toc3"></A>
<H2>Maintainer documentation for ModuleTermOrdering</H2>
<P>
The general ideas behind the implementations of ModuleTermOrdering and
ModuleTermOrderingBase are analogous to those used for ring and RingBase.
ModuleTermOrdering is a simple reference counting smart-pointer class, while
ModuleTermOrderingBase hosts the intrusive reference count (so that
every concrete derived class will inherit it).  <A HREF="SmartPtrIRC.txt">See</A>
</P>
<P>
The only remaining observation to make about the simple class
ModuleTermOrdering is that I have chosen to disable assignment -- I
find it hard to imagine when it could be useful to be able to assign
ModuleTermOrderings, and suspect that allowing assignment is more
likely to lead to confusion and poor programming style.
</P>
<P>
There are ? concrete ModuleTermOrderings in the namespace CoCoA::MTO.  The
implementations are all simple and straightforward except for the matrix
ordering which is a little longer and messier but still easy enough to
follow.
</P>
<P>
See also the CoCoAReport "Free Modules".
</P>
<A NAME="toc4"></A>
<H2>Bugs, shortcomings and other ideas</H2>
<A NAME="toc5"></A>
<H3>do we need a class "shifts"?</H3>
<HR NOSHADE SIZE=1>

<!-- html code generated by txt2tags 2.5 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags -t html -o html/ModuleTermOrdering.html -i txt/ModuleTermOrdering.txt -->
</BODY></HTML>
