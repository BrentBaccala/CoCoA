<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<LINK REL="stylesheet" TYPE="text/css" HREF="cocoalib-doc.css">
<TITLE>      SmallFpDoubleImpl</TITLE>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<CENTER>
<H1>      SmallFpDoubleImpl</H1>
<FONT SIZE="4"><I>      &copy;  2005,2010-2013 John Abbott</I></FONT><BR>
<FONT SIZE="4">      GNU Free Documentation License, Version 1.2</FONT>
</CENTER>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>

    <UL>
    <LI><A HREF="#toc1">User documentation for SmallFpDoubleImpl</A>
    <LI><A HREF="#toc2">Maintainer documentation for SmallFpDoubleImpl</A>
    <LI><A HREF="#toc3">Bugs, Shortcomings, and other ideas</A>
    </UL>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<P>
      <center><a href="index.html">CoCoALib Documentation Index</a></center>
</P>

<A NAME="toc1"></A>
<H2>User documentation for SmallFpDoubleImpl</H2>

<P>
The class <CODE>SmallFpDoubleImpl</CODE> is a very low level implementation class
for fast arithmetic in a small, prime finite field.  It is <B>not intended</B>
for use by casual CoCoALib users, who should instead see the documentation
in <A HREF="QuotientRing.html"><CODE>QuotientRing</CODE></A> (in particular the function <CODE>NewZZmod</CODE>), or possibly
the documentation in <A HREF="RingFp.html"><CODE>RingFp</CODE></A>, <A HREF="RingFpLog.html"><CODE>RingFpLog</CODE></A>, and <A HREF="RingFpDouble.html"><CODE>RingFpDouble</CODE></A>.
</P>
<P>
Compared to <A HREF="SmallFpImpl.html"><CODE>SmallFpImpl</CODE></A> the main difference is an implementation
detail: values are represented as <CODE>double</CODE>s -- on 32-bit computers this
allows a potentially usefully greater range of characteristics at a
probably minor run-time cost.
</P>
<P>
<B>All operations</B> on values must be effected by calling member functions
of the <CODE>SmallFpDoubleImpl</CODE> class.  Here is a brief summary.
</P>

<PRE>
    SmallFpDoubleImpl::IsGoodCtorArg(p);   // true iff ctor SmallFpDoubleImpl(p) will succeed
    SmallFpDoubleImpl::ourMaxModulus();    // largest permitted modulus
    SmallFpDoubleImpl ModP(p, convention); // create SmallFpDoubleImpl object
    long n;
    BigInt N;
    BigRat q;
    SmallFpImpl::value_t a, b, c;
  
    ModP.myModulus();         // value of p (as a long)
  
    ModP.myReduce(n);         // reduce mod p
    ModP.myReduce(N);         // reduce mod p
    ModP.myReduce(q);         // reduce mod p
  
    ModP.myExport(a);         // returns a preimage (of type long) according to symm/non-neg convention.
  
    ModP.myNegate(a);         // -a mod p
    ModP.myAdd(a, b);         // (a+b)%p;
    ModP.mySub(a, b);         // (a-b)%p;
    ModP.myMul(a, b);         // (a*b)%p;
    ModP.myDiv(a, b);         // (a*inv(b))%p;  where inv(b) is inverse of b
    ModP.myPower(a, n);       // (a^n)%p;  where ^ means "to the power of"
    ModP.myIsZeroAddMul(a,b,c) // a = (a+b*c)%p; result is (a==0)
  
</PRE>

<P>
For <CODE>myExport</CODE> the choice between least non-negative and symmetric
residues is determined by the convention specified when constructing
the <CODE>SmallFpDoubleImpl</CODE> object.  This convention may be either
<CODE>GlobalSettings::SymmResidues</CODE> or
<CODE>GlobalSettings::NonNegResidues</CODE>.
</P>

<A NAME="toc2"></A>
<H2>Maintainer documentation for SmallFpDoubleImpl</H2>

<P>
Most functions are implemented inline, and no sanity checks are
performed (except when <CODE>CoCoA_DEBUG</CODE> is enabled).  The constructor
does do some checking.  The basic idea is to use the extra precision
available in <CODE>double</CODE>s to allow larger prime finite fields than are
permitted when 32-bit integers are used for all arithmetic.  If fast
64-bit arithmetic becomes widespread then this class will probably
become obsolete (unless you have a very fast floating point coprocessor?).
</P>
<P>
<CODE>SmallFpDoubleImpl::value_t</CODE> is simply <CODE>double</CODE>.  Note that the
values are always non-negative integers with maximum value less than
<CODE>myModulusValue</CODE>; <I>i.e.</I> each residue class is represented
(internally) by its least non-negative member.
</P>
<P>
To avoid problems with overflow the constructor checks that all
integers from 0 to p*p-p can be represented exactly.  We need to allow
numbers as big as p*p-p so that <CODE>myIsZeroAddMul</CODE> can be implemented easily.
</P>
<P>
It is not strictly necessary that <CODE>myModulusValue</CODE> be prime, though division
becomes only a partial map if <CODE>myModulusValue</CODE> is composite.  I believe it is
safest to insist that <CODE>myModulusValue</CODE> be prime.
</P>

<A NAME="toc3"></A>
<H2>Bugs, Shortcomings, and other ideas</H2>

<P>
The implementation is simplistic -- I wanted to dash it off quickly
before going on holiday :-)
</P>

<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -o html/SmallFpDoubleImpl.html -i txt/SmallFpDoubleImpl.txt -->
</BODY></HTML>
